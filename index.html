<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Wi-Fi Walkie Talkie</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827; /* Gray 900 */
            color: #f3f4f6; /* Gray 100 */
            overscroll-behavior: none;
        }
        
        .mono { font-family: 'JetBrains Mono', monospace; }

        /* PTT Button Animation */
        .ptt-btn {
            transition: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7);
        }
        .ptt-btn:active, .ptt-btn.active {
            transform: scale(0.95);
            box-shadow: 0 0 0 30px rgba(239, 68, 68, 0);
        }
        
        .ptt-active-ring {
            animation: ripple 1.5s infinite;
        }

        @keyframes ripple {
            0% { transform: scale(0.95); box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
            70% { transform: scale(1.1); box-shadow: 0 0 0 20px rgba(239, 68, 68, 0); }
            100% { transform: scale(0.95); box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); }
        }

        /* Custom Scrollbar for logs */
        .scrollbar-thin::-webkit-scrollbar { width: 6px; }
        .scrollbar-thin::-webkit-scrollbar-track { background: #1f2937; }
        .scrollbar-thin::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 3px; }

        /* Hide generic scrollbars */
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
    </style>
</head>
<body class="h-[100dvh] w-screen flex flex-col overflow-hidden">

    <!-- Header -->
    <header class="flex-none p-4 bg-gray-800 border-b border-gray-700 flex justify-between items-center z-10">
        <div class="flex items-center gap-2">
            <div class="w-3 h-3 rounded-full bg-gray-500" id="status-dot"></div>
            <h1 class="font-bold text-lg tracking-tight">NET-COM <span class="text-xs font-normal text-gray-400 ml-1 mono" id="version">v1.0</span></h1>
        </div>
        <button id="settings-toggle" class="p-2 text-gray-400 hover:text-white transition-colors">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.38a2 2 0 0 0-.73-2.73l-.15-.1a2 2 0 0 1-1-1.72v-.51a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></svg>
        </button>
    </header>

    <!-- Main Content -->
    <main class="flex-1 flex flex-col items-center justify-center relative bg-gray-900">
        
        <!-- Audio Visualizer -->
        <canvas id="visualizer" class="absolute top-0 left-0 w-full h-full opacity-20 pointer-events-none"></canvas>

        <!-- Status Text -->
        <div class="absolute top-8 text-center z-10">
            <div id="connection-status" class="text-yellow-500 font-mono text-sm mb-1">INITIALIZING</div>
            <div id="peer-id-display" class="text-gray-600 text-xs font-mono hidden">ID: <span id="my-id">...</span></div>
        </div>

        <!-- PTT Button Area -->
        <div class="relative z-20 flex flex-col items-center justify-center w-full h-full">
            <div class="relative group">
                <div id="ptt-ring" class="absolute inset-0 bg-red-500 rounded-full opacity-0"></div>
                <button id="ptt-btn" disabled class="ptt-btn w-64 h-64 rounded-full bg-gray-800 border-8 border-gray-700 flex items-center justify-center focus:outline-none disabled:opacity-50 disabled:cursor-not-allowed group-active:border-red-500 transition-colors relative overflow-hidden">
                    <span class="relative z-10 text-2xl font-bold tracking-widest text-gray-300 group-active:text-white select-none pointer-events-none">HOLD TO TALK</span>
                    <div class="absolute inset-0 bg-red-600 opacity-0 group-active:opacity-100 transition-opacity"></div>
                </button>
            </div>
            <p class="mt-8 text-gray-500 text-sm select-none">Press and hold Spacebar or click button</p>
        </div>

        <!-- Volume Meter (Incoming) -->
        <div class="absolute bottom-8 w-64 h-2 bg-gray-800 rounded-full overflow-hidden">
            <div id="volume-bar" class="h-full bg-green-500 w-0 transition-all duration-75"></div>
        </div>
    </main>

    <!-- Settings / Signaling Panel -->
    <div id="settings-panel" class="fixed inset-y-0 right-0 w-full md:w-96 bg-gray-900 border-l border-gray-800 transform translate-x-full transition-transform duration-300 z-50 flex flex-col shadow-2xl">
        <div class="p-4 border-b border-gray-800 flex justify-between items-center bg-gray-800">
            <h2 class="font-bold">Configuration</h2>
            <button id="close-settings" class="text-gray-400 hover:text-white">&times;</button>
        </div>
        
        <div class="flex-1 overflow-y-auto p-4 space-y-6 scrollbar-thin">
            
            <!-- Signaling Mode Switch -->
            <div class="bg-gray-800 p-3 rounded-lg">
                <label class="text-xs text-gray-400 uppercase font-semibold">Signaling Mode</label>
                <div class="flex mt-2 bg-gray-900 rounded p-1">
                    <button id="mode-auto" class="flex-1 py-1 text-sm rounded bg-blue-600 text-white shadow-sm transition-all">Auto (WS)</button>
                    <button id="mode-manual" class="flex-1 py-1 text-sm rounded text-gray-400 hover:text-gray-200 transition-all">Manual</button>
                </div>
            </div>

            <!-- Auto Mode Config -->
            <div id="section-auto" class="space-y-3">
                <div>
                    <label class="text-xs text-gray-400">Signaling Server URL</label>
                    <input type="text" id="ws-url" value="wss://echo.websocket.org" class="w-full bg-gray-950 border border-gray-700 rounded p-2 text-sm text-white focus:border-blue-500 focus:outline-none font-mono mt-1" placeholder="ws://localhost:8080">
                    <p class="text-[10px] text-gray-500 mt-1">Use a WebSocket server that relays messages to other connected peers.</p>
                </div>
                <button id="btn-connect-ws" class="w-full bg-blue-600 hover:bg-blue-500 text-white py-2 rounded font-medium text-sm transition-colors">Connect to Server</button>
            </div>

            <!-- Manual Mode Config -->
            <div id="section-manual" class="space-y-4 hidden">
                <div class="p-3 bg-yellow-900/20 border border-yellow-700/50 rounded text-yellow-200 text-xs">
                    Fallback mode. Copy the SDP Offer from Device A and paste into Device B, then copy Answer back.
                </div>

                <!-- Step 1: Offer -->
                <div class="space-y-2">
                    <div class="flex justify-between items-center">
                        <label class="text-xs text-gray-400 font-bold">1. Local Offer/Answer</label>
                        <button id="btn-create-offer" class="text-xs bg-gray-700 px-2 py-1 rounded hover:bg-gray-600">Create Offer</button>
                    </div>
                    <textarea id="local-sdp" readonly class="w-full h-24 bg-gray-950 border border-gray-700 rounded p-2 text-[10px] font-mono text-gray-300 resize-none focus:outline-none" placeholder="Click 'Create Offer' to generate SDP..."></textarea>
                    <button id="btn-copy-local" class="w-full border border-gray-700 text-gray-300 py-1 rounded text-xs hover:bg-gray-800">Copy to Clipboard</button>
                </div>

                <!-- Step 2: Answer -->
                <div class="space-y-2 pt-2 border-t border-gray-800">
                    <label class="text-xs text-gray-400 font-bold">2. Remote SDP</label>
                    <textarea id="remote-sdp" class="w-full h-24 bg-gray-950 border border-gray-700 rounded p-2 text-[10px] font-mono text-gray-300 resize-none focus:border-blue-500 focus:outline-none" placeholder="Paste remote SDP here..."></textarea>
                    <button id="btn-process-remote" class="w-full bg-green-700 hover:bg-green-600 text-white py-2 rounded text-sm font-medium">Process Remote SDP</button>
                </div>
            </div>

            <!-- Device Config -->
            <div class="space-y-3 pt-4 border-t border-gray-800">
                <h3 class="text-sm font-bold text-gray-300">Audio Settings</h3>
                <div class="flex items-center justify-between">
                    <span class="text-sm text-gray-400">Microphone</span>
                    <button id="btn-req-perm" class="text-xs text-blue-400 hover:text-blue-300">Request Permission</button>
                </div>
            </div>

            <!-- Logs -->
            <div class="space-y-2 pt-4 border-t border-gray-800 flex-1 flex flex-col min-h-[200px]">
                <div class="flex justify-between items-center">
                    <h3 class="text-sm font-bold text-gray-300">System Logs</h3>
                    <button id="btn-clear-logs" class="text-xs text-gray-500 hover:text-gray-300">Clear</button>
                </div>
                <div id="logs" class="flex-1 bg-black/50 rounded p-2 font-mono text-[10px] text-green-400 overflow-y-auto scrollbar-thin">
                    <div class="text-gray-500">System ready...</div>
                </div>
            </div>

        </div>
    </div>

    <script>
        /**
         * NET-COM: Single File WebRTC Walkie Talkie
         * 
         * USAGE:
         * 1. Open this file in two browser windows/devices (https required for non-localhost).
         * 2. Allow Microphone access.
         * 3. AUTO MODE: Enter a WebSocket URL (e.g. local 'ws://localhost:8080') and click Connect.
         *    The server just needs to broadcast messages to the other peer.
         * 4. MANUAL MODE:
         *    - Peer A: Click "Create Offer". Copy text.
         *    - Peer B: Paste text into "Remote SDP". Click "Process Remote SDP".
         *    - Peer B: Copy generated text (Answer).
         *    - Peer A: Paste text into "Remote SDP". Click "Process Remote SDP".
         */

        // --- CONFIGURATION ---
        const ICE_SERVERS = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' }
            ]
        };

        // --- STATE ---
        let localStream = null;
        let peerConnection = null;
        let ws = null;
        let isInitiator = false;
        let signalingMode = 'auto'; // 'auto' | 'manual'
        let audioContext = null;
        let analyser = null;
        let sourceNode = null;
        let isTalking = false;

        // --- DOM ELEMENTS ---
        const ui = {
            statusDot: document.getElementById('status-dot'),
            statusText: document.getElementById('connection-status'),
            pttBtn: document.getElementById('ptt-btn'),
            pttRing: document.getElementById('ptt-ring'),
            visualizer: document.getElementById('visualizer'),
            volumeBar: document.getElementById('volume-bar'),
            settingsPanel: document.getElementById('settings-panel'),
            toggleSettings: document.getElementById('settings-toggle'),
            closeSettings: document.getElementById('close-settings'),
            modeAutoBtn: document.getElementById('mode-auto'),
            modeManualBtn: document.getElementById('mode-manual'),
            sectionAuto: document.getElementById('section-auto'),
            sectionManual: document.getElementById('section-manual'),
            wsUrl: document.getElementById('ws-url'),
            connectWsBtn: document.getElementById('btn-connect-ws'),
            createOfferBtn: document.getElementById('btn-create-offer'),
            localSdp: document.getElementById('local-sdp'),
            remoteSdp: document.getElementById('remote-sdp'),
            processRemoteBtn: document.getElementById('btn-process-remote'),
            copyLocalBtn: document.getElementById('btn-copy-local'),
            reqPermBtn: document.getElementById('btn-req-perm'),
            logs: document.getElementById('logs'),
            clearLogs: document.getElementById('btn-clear-logs')
        };

        // --- UTILS ---
        function log(msg, type = 'info') {
            const div = document.createElement('div');
            const time = new Date().toLocaleTimeString().split(' ')[0];
            div.innerHTML = `<span class="opacity-50">[${time}]</span> ${msg}`;
            if (type === 'error') div.className = 'text-red-400';
            else if (type === 'success') div.className = 'text-blue-400';
            else div.className = 'text-green-400';
            ui.logs.appendChild(div);
            ui.logs.scrollTop = ui.logs.scrollHeight;
            console.log(`[${type.toUpperCase()}]`, msg);
        }

        function setStatus(status) {
            ui.statusText.innerText = status;
            ui.statusDot.className = 'w-3 h-3 rounded-full ' + 
                (status === 'CONNECTED' ? 'bg-green-500 shadow-[0_0_10px_rgba(34,197,94,0.5)]' : 
                 status === 'DISCONNECTED' ? 'bg-red-500' : 
                 status === 'READY' ? 'bg-blue-500' : 'bg-yellow-500 animate-pulse');
            
            if (status === 'CONNECTED') {
                ui.pttBtn.disabled = false;
            } else {
                ui.pttBtn.disabled = true;
            }
        }

        // --- AUDIO HANDLING ---
        async function initAudio() {
            try {
                // Low latency constraints
                const constraints = {
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true,
                        latency: 0,
                        channelCount: 1
                    },
                    video: false
                };
                
                localStream = await navigator.mediaDevices.getUserMedia(constraints);
                
                // Mute by default (PTT logic)
                localStream.getAudioTracks().forEach(track => {
                    track.enabled = false;
                });

                log('Microphone access granted', 'success');
                ui.reqPermBtn.innerText = 'Access Granted';
                ui.reqPermBtn.disabled = true;
                
                // If manual mode, initialize PC now. If Auto, wait for WS.
                if (signalingMode === 'manual' && !peerConnection) {
                    createPeerConnection();
                }

            } catch (e) {
                log('Microphone access denied: ' + e.message, 'error');
                alert('Microphone access is required for this app to work.');
            }
        }

        function createPeerConnection() {
            if (peerConnection) return;
            
            log('Creating RTCPeerConnection...');
            peerConnection = new RTCPeerConnection(ICE_SERVERS);

            // Add local tracks
            if (localStream) {
                localStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, localStream);
                });
            }

            // Handle ICE Candidates
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    if (signalingMode === 'websocket' && ws && ws.readyState === WebSocket.OPEN) {
                        ws.send(JSON.stringify({ type: 'candidate', candidate: event.candidate }));
                    } 
                    // For manual, we wait for 'complete' usually, or user copies partial. 
                    // We'll update the textarea dynamically if we are waiting for gathering to complete.
                } else {
                    // Gathering complete
                    if (signalingMode === 'manual') {
                        ui.localSdp.value = JSON.stringify(peerConnection.localDescription);
                        log('ICE Gathering complete. Copy the JSON below.');
                    }
                }
            };

            // Handle Connection State
            peerConnection.onconnectionstatechange = () => {
                const state = peerConnection.connectionState.toUpperCase();
                setStatus(state);
                log(`Connection State: ${state}`);
            };

            peerConnection.oniceconnectionstatechange = () => {
                log(`ICE State: ${peerConnection.iceConnectionState}`);
            };

            // Handle Remote Stream
            peerConnection.ontrack = (event) => {
                log('Remote track received');
                const remoteStream = event.streams[0];
                const audio = new Audio();
                audio.srcObject = remoteStream;
                audio.autoplay = true;
                audio.play().catch(e => log('Autoplay failed: ' + e, 'error'));
                
                setupVisualizer(remoteStream);
            };
        }

        // --- PTT LOGIC ---
        function startTalking() {
            if (!localStream || !peerConnection || peerConnection.connectionState !== 'connected') return;
            if (isTalking) return;
            
            isTalking = true;
            localStream.getAudioTracks().forEach(track => track.enabled = true);
            
            ui.pttBtn.classList.add('active');
            ui.pttRing.classList.add('ptt-active-ring');
            
            // Haptic feedback
            if (navigator.vibrate) navigator.vibrate(50);
            
            log('PTT: Transmitting...', 'success');
        }

        function stopTalking() {
            if (!isTalking) return;
            
            isTalking = false;
            localStream.getAudioTracks().forEach(track => track.enabled = false);
            
            ui.pttBtn.classList.remove('active');
            ui.pttRing.classList.remove('ptt-active-ring');
            
            log('PTT: Muted');
        }

        // --- SIGNALING: MANUAL ---
        async function createManualOffer() {
            if (!peerConnection) createPeerConnection();
            try {
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                ui.localSdp.value = "Generating ICE candidates... wait...";
                // We let onicecandidate fill the final JSON
            } catch (e) {
                log('Error creating offer: ' + e, 'error');
            }
        }

        async function processManualRemote() {
            if (!peerConnection) createPeerConnection();
            try {
                const sdpStr = ui.remoteSdp.value.trim();
                if (!sdpStr) return alert('Paste remote JSON first');
                
                const data = JSON.parse(sdpStr);
                
                if (data.sdp || data.type === 'offer' || data.type === 'answer') {
                    // It's an SDP
                    await peerConnection.setRemoteDescription(new RTCSessionDescription(data));
                    log('Remote description set', 'success');

                    if (data.type === 'offer') {
                        const answer = await peerConnection.createAnswer();
                        await peerConnection.setLocalDescription(answer);
                        ui.localSdp.value = "Generating Answer ICE... wait...";
                        log('Created Answer. Wait for JSON then copy to Peer A.');
                    }
                }
            } catch (e) {
                log('Error processing remote SDP: ' + e, 'error');
            }
        }

        // --- SIGNALING: WEBSOCKET (AUTO) ---
        function connectWebSocket() {
            const url = ui.wsUrl.value;
            if (!url) return alert('Enter a WS URL');

            log(`Connecting to ${url}...`);
            try {
                ws = new WebSocket(url);
                
                ws.onopen = () => {
                    log('WebSocket Connected', 'success');
                    setStatus('READY');
                    createPeerConnection();
                    
                    // Simple discovery: Announce presence. 
                    // For this simple demo, we just send an Offer immediately if we are the "initiator" 
                    // (randomly decided or button trigger). 
                    // Let's rely on a button "Start Call" or just simple "Create Offer" logic automator.
                    // But to make it auto, let's wait 1s. If no offer received, send one.
                    // This is naive signaling logic for a demo.
                    setTimeout(() => {
                        if (peerConnection.signalingState === 'stable') {
                             // Try to be the caller
                             initiateCall();
                        }
                    }, 2000);
                };

                ws.onmessage = async (msg) => {
                    try {
                        let data = JSON.parse(msg.data);
                        // Handle generic relay wrappers if specific server used
                        if (data.message) data = JSON.parse(data.message);

                        if (data.type === 'offer') {
                            log('Received Offer via WS');
                            if (!peerConnection) createPeerConnection();
                            await peerConnection.setRemoteDescription(new RTCSessionDescription(data));
                            const answer = await peerConnection.createAnswer();
                            await peerConnection.setLocalDescription(answer);
                            ws.send(JSON.stringify(peerConnection.localDescription));
                            log('Sent Answer via WS');
                        } else if (data.type === 'answer') {
                            log('Received Answer via WS');
                            await peerConnection.setRemoteDescription(new RTCSessionDescription(data));
                        } else if (data.type === 'candidate' && data.candidate) {
                            log('Received ICE via WS');
                            try {
                                await peerConnection.addIceCandidate(data.candidate);
                            } catch (e) { console.error(e); }
                        }
                    } catch (e) {
                        // ignore parsing errors
                    }
                };
                
                ws.onerror = (e) => log('WS Error: Check console', 'error');
                ws.onclose = () => {
                    log('WS Closed', 'error');
                    setStatus('DISCONNECTED');
                };
            } catch (e) {
                log('Invalid WS URL', 'error');
            }
        }

        async function initiateCall() {
            if (!peerConnection) createPeerConnection();
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify(peerConnection.localDescription));
                log('Sent Offer via WS');
            }
        }

        // --- AUDIO VISUALIZER ---
        function setupVisualizer(stream) {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            // Resume context if suspended (browser policy)
            if (audioContext.state === 'suspended') audioContext.resume();

            analyser = audioContext.createAnalyser();
            analyser.fftSize = 256;
            sourceNode = audioContext.createMediaStreamSource(stream);
            sourceNode.connect(analyser);

            const canvas = ui.visualizer;
            const ctx = canvas.getContext('2d');
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);

            const draw = () => {
                requestAnimationFrame(draw);
                
                // Canvas resize logic
                if (canvas.width !== canvas.clientWidth || canvas.height !== canvas.clientHeight) {
                    canvas.width = canvas.clientWidth;
                    canvas.height = canvas.clientHeight;
                }

                analyser.getByteFrequencyData(dataArray);

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Draw circular visualizer
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const radius = Math.min(centerX, centerY) * 0.8;

                ctx.beginPath();
                ctx.arc(centerX, centerY, radius * 0.5, 0, 2 * Math.PI);
                ctx.strokeStyle = '#374151';
                ctx.stroke();

                // Simple bars or pulsing
                let sum = 0;
                for(let i=0; i < bufferLength; i++) {
                    sum += dataArray[i];
                }
                const average = sum / bufferLength;

                // Volume Bar UI
                const volPct = Math.min(100, (average / 128) * 100);
                ui.volumeBar.style.width = `${volPct}%`;
                
                // Pulse effect
                if (average > 10) {
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, (radius * 0.5) + (average * 0.5), 0, 2 * Math.PI);
                    ctx.fillStyle = `rgba(34, 197, 94, ${average / 255 * 0.2})`;
                    ctx.fill();
                }
            };
            draw();
        }

        // --- EVENT LISTENERS ---
        
        // PTT Interaction
        ui.pttBtn.addEventListener('mousedown', startTalking);
        ui.pttBtn.addEventListener('touchstart', (e) => { e.preventDefault(); startTalking(); });
        
        window.addEventListener('mouseup', stopTalking);
        window.addEventListener('touchend', stopTalking);
        
        // Keyboard PTT (Spacebar)
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && !e.repeat && document.activeElement.tagName !== 'INPUT' && document.activeElement.tagName !== 'TEXTAREA') {
                e.preventDefault(); // Prevent scrolling
                startTalking();
            }
        });
        document.addEventListener('keyup', (e) => {
            if (e.code === 'Space') stopTalking();
        });

        // Settings UI
        ui.toggleSettings.addEventListener('click', () => {
            ui.settingsPanel.classList.toggle('translate-x-full');
        });
        ui.closeSettings.addEventListener('click', () => {
            ui.settingsPanel.classList.add('translate-x-full');
        });

        // Mode Switching
        const setMode = (mode) => {
            signalingMode = mode;
            if (mode === 'auto') {
                ui.modeAutoBtn.classList.replace('text-gray-400', 'text-white');
                ui.modeAutoBtn.classList.replace('hover:text-gray-200', 'bg-blue-600');
                ui.modeManualBtn.classList.replace('text-white', 'text-gray-400');
                ui.modeManualBtn.classList.replace('bg-blue-600', 'hover:text-gray-200');
                ui.modeManualBtn.classList.remove('bg-blue-600');
                
                ui.sectionAuto.classList.remove('hidden');
                ui.sectionManual.classList.add('hidden');
            } else {
                ui.modeManualBtn.classList.replace('text-gray-400', 'text-white');
                ui.modeManualBtn.classList.add('bg-blue-600');
                ui.modeManualBtn.classList.remove('hover:text-gray-200');
                ui.modeAutoBtn.classList.replace('text-white', 'text-gray-400');
                ui.modeAutoBtn.classList.remove('bg-blue-600');
                ui.modeAutoBtn.classList.add('hover:text-gray-200');

                ui.sectionAuto.classList.add('hidden');
                ui.sectionManual.classList.remove('hidden');
                
                // Ensure PC exists for manual mode
                initAudio();
            }
        };

        ui.modeAutoBtn.addEventListener('click', () => setMode('auto'));
        ui.modeManualBtn.addEventListener('click', () => setMode('manual'));

        // Actions
        ui.connectWsBtn.addEventListener('click', () => {
            initAudio().then(connectWebSocket);
        });

        ui.createOfferBtn.addEventListener('click', createManualOffer);
        ui.processRemoteBtn.addEventListener('click', processManualRemote);
        ui.copyLocalBtn.addEventListener('click', () => {
            ui.localSdp.select();
            document.execCommand('copy');
            log('Copied to clipboard', 'success');
        });

        ui.reqPermBtn.addEventListener('click', initAudio);
        ui.clearLogs.addEventListener('click', () => ui.logs.innerHTML = '');

        // Init
        setStatus('DISCONNECTED');
        log('Application loaded. Please configure connection.');

    </script>
</body>
</html>
